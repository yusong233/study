# 算法第一次作业

​															170617  17373126  刘萱

## 一、

![1570627254094](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\1570627254094.png)

```
T(n) = T(n-2) + n
	 = T(n-4) + (n-2) + n
	 = T(n-6) + (n-4) + (n-2) + n
	 = ...
	 = T(2) + 4 + 6 + ... + n
	 = 1 + 4 + 6 + ... + n
	 = n² - (3n²/4 - n + 2)
	 <= n²
Thus  T(n) = O(n²)
```

![1570627272838](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\1570627272838.png)

```
T(n) = 4T(n/2) + n
     = 16T(n/4) + 4(n/2) + n
     = ...
     = n(1 + 2 + 4 + 8 + ... + 2^(logn-1))
     <= n²
Thus T(n) = O(n²)
```

![1570627240835](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\1570627240835.png)

```
T(n) = 2T(n/2) + n
	 = 2T(n/4) + 2(n/2) + n
	 = 2T(n/8) + 4(n/4) + n + n
	 = ...
	 = nlogn
Thus T(n) = O(nlogn)
```

![1570627284431](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\1570627284431.png)

![](C:\Users\yusong\Desktop\QQ图片20191009214303.png)

```
T(n) = 2T(n/2) + nlogn
	 = 2T(n/4) + n(logn - 1) + nlogn
	 = 2T(n/4) + n(logn - 2) + n(logn - 1) + nlogn
	 = ...
	 = n(logn)² - n(1 + 2 + ... + （logn-1)）
	 <= 2nlogn
Thus T(n) = O(nlogn)
```

![1570628657469](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\1570628657469.png)

``` 
T(n) = 2T(n/2) + n²
	 = 2T(n/4) + 2(n/2)² + n²
	 = 2T(n/8) + 2²(n/4)² + n²/2 + n²
	 = ...
	 = n²(1 + 1/2 + (1/2)² + ... + (1/2)^logn)
	 = 2n²
Thus T(n) = O(n²)
```

![1570629351062](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\1570629351062.png)

```
T(n) = 3T(n/2) + n
	 = 3T(n/4) + 3(n/2) + n
	 = 3T(n/8) + (3/2)²n + 3n/2 + n
     = ...
     = n(1 + 3/2 + (3/2)² + ... + (3/2)^(logn-1))
     <= n + (n^log3)
Thus T(n) = O(n^log3)
```

![1570629993126](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\1570629993126.png)

```
T(n) = T(n/2) + nlogn
	 = T(n/4) + n/2(logn - 1) + nlogn
	 = T(n/8) + n/4(logn - 2) + n/2(logn - 1) + nlogn
	 = ... 
	 = logn(n + n/2 + n/4 + ... + n/n)  - (n/2 + 2n/4 + 3n/8 + ... + nlogn/n)
	 <= logn(nlogn/2 + n)
Thus T(n) = O(n(logn)²)
```



## 二、k路归并问题

![1570641682640](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\1570641682640.png)

1.

```
T(n) = O(n+n) + O(2n+n) + ... + O((k-1)n+n)
     = O(2n) + O(3n) + ... + O(kn)
     = O((k-1)(k+2)n/2)
```

2.

使用一个最小堆做k路归并排序，对于k个有序数组（升序排列）

​	1.建堆，分别取k个数组的第一个值建立最小堆 `O(k)`

​	2.取出堆顶元素，即为最小元素 `O(1)`

​	3.若堆顶元素所在数组不为空，取下一个元素放在堆顶，调整最小堆 `O(logk)`

​	 若堆顶元素所在数组为空，则删除最小堆的堆顶元素，最小堆`heapSize--` `O(logk)`

​	重复2、3直到所有序列为空（`heapSize`为0）

总的时间复杂度为 : `O(k) + O(nklogk) = O(nklogk)`



## 三、战线补给问题

`Devide(A,p,r)`

**Input** : An array **A**, the length of A **l**

**Output** : Amount of replenishment

```c
sum <- 0;
L = r-p+1;
if L >= 2 then
	q <- p + L/2;
	sum1 <- Devide(A,p,q);
	sum2 <- Devide(A,q+1,r);
	if sum1 == A && sum2 == A then
		sum <- A;
	end
	else  
		sum <- sum1 + sum2;
	return sum;
end
else then
	if A[p] == 0 then
		return A;
	end
	else 
        return A[p]*B;
end
```

`Supply(A,n,l)`

**Input** : An array **Arr** indicates which fortress each soldier is in, the number of soldiers **n**,the index of the fortress `l`

**Output** : Amount of replenishment

```c
A[] <- {0}; // arr is number of people per fortress 
for i<-0 to n-1 do
    A[Arr[i]] <- A[Arr[i]] + 1;
end
sum <- Devide(A,0,2^l-1);
return sum;
```

时间复杂度： `T(n) = O( n + 2l²)`



## 四、区间计数问题

![1570689550762](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\1570689550762.png)    

`MergeSort(sum,lower,upper,low,high)`

**Input** : An array `sum`,  lower bound **lower**,upper bound **upper**,index **low**,index **high**

**Output** : the number of interval sums

```c
if high - low <= 1 then 
	return 0;
end
mid <-(low + high)/2;
m <- mid;
n <- mid;
count <- 0;
count <- MergeSort(sum,lowwer,upper,low,mid) + MergeSort(sum,lower,upper,mid,high);
for i<-low to mid-1 do
	while m < high && sum[m] - sum[i] < lower do
		m++;
	end
	while n < high && sum[n] - sum[i] <= upper do
    	n++;
    end
    count <- count + n - m;
end
return count;
```

`Count(num,lower,upper)`

**Input** : An array `num ` contains n number,lower bound **lower**,upper bound **upper**

**Output** : the number of interval sums

```c
sum <- 0;
for i<-0 to n-1 do
	sum <- sum + num[i]
	sum[i] = sum;
end
return MergeSort(sum, lower, upper, 0, n+1);
```

时间复杂度： `T(n) = O(nlogn)`



## 五、向量的最小和问题

将所有的n个向量映射到第一象限，问题可简化为求n个点中距离最小的两个间距

采用分治的思想，把n个点按照x坐标进行排序，以坐标`mid`为界限分成左右两个部分，对左右两个部分分别求最近点对的距离，然后进行合并。对于两个部分求得的最近距离`d`，合并过程中应当检查宽为`2d`的带状区间是否有两个点分属于两个集合而且距离小于`d`.

`cmpx(v1,v2)`

```c
return v1.x < v2.x;
```

`cmpy(v1,v2)`

```c
return v1.y < v2.y;
```

`min(a,b)`

```c
return a < b ? a : b;
```

`dis(v1,v2)`

```c
return sqrt((v1.x-v2.x)^2 + (v1.y - v2.y)^2);
```

`deal(p,q)`

```c
tail <- 0;//计数变量
mid <- (p+q)/2;
d <- min(deal(p,mid),deal(mid+1,q));
for i<-mid to p && arr[mid].x - arr[i].x < d do
	rarr[tail++] <- arr[i];
end
for i<-mid+1 to q && arr[i].x - arr[mid].x < d do
	rarr[tail++] <- arr[i];
end
sort(br,br+tail,cmpy);                      　　　　　　　　　　　　　　　　　　
for i<-0 to tail-1 do
	for j<-i+1 to tail-1 && rarr[j].y-rarr[i].y<d do
    	if d>dis(rarr[i],rarr[j]) then           
        	d=min(d,dis(br[i],br[j]));   
        end
    end
end
return d;            
```

`count(arr,n)`

```c
sort(arr,arr+n,cmpx);         
d <- deal(0,n);                       
return d;
```

时间复杂度：`T(n) = O(nlogn)`