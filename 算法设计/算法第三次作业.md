# 算法第三次作业

*170617 17373126 刘萱*

## 一、

![image-20191124204342949](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\image-20191124204342949.png)

**思路**：要使S中交换两个元素的位置后，最多连续0的个数发生改变，则这两个被交换的元素必须为0和1。设置一个数组*v*，如果S[*k*] = 0，则*v*[*k*] = -1；如果S[*k*] = 1，则*v*[*k*] 表示S[*k*]前后连续0个数之和。现交换两个元素，这两个元素在原01串S中的下标分别为*i*和*j*,那么S[*i*]随对应的*v*[*i*] = *MAX*{ *v*[ *k* ] },(1<= *k* <= n )，其中S[k] = 1。

```c
Input : 01串S
Output : 交换S中两个元素后S中连续0的最长个数

Let V[n] be a new array,each element is set to 0
sum_pre <- 0;
sun_aft <- 0;
index_pre <- -1;//记录前一个1的下标
max <- 0;//记录MAX{v[k]}
for i<-1 to n do
    if S[i] == 1 then
		if index_pre != -1 then
            V[index_pre] <- sum_pre + sum_aft;
			if V[index_pre] > max then//更新MAX{v[k]}
                max = V[index_pre];
			end
			sum_pre <- sum_aft;
			sum_aft <- 0;
		end
        index_pre <- i;
	end
    else then
        V[i] <- -1;
		sum_aft <- sum_aft + 1;
	end
    if index_pre == n then
        V[index_pre] <- sum_pre;
	end
end
return max + 1;
```

由于算法只需要遍历一遍S串，所以算法的时间复杂度`T(n) = O(n)`.



## 二、

![image-20191124204428819](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\image-20191124204428819.png)

**思路**：每次升级机器的成本为U，之后从当天起每天多获得的收益为`X2`。那么，当总的收益大于升级所需要的成本时选择升级，否则不升级。设升级之后还可以生产k天，若`X2`*k > U，则选择升级。要使得收益最大，在满足条件且剩余资金大于等于U元时，越早升级所获得的收益越多。

```c
Input : X1,X2,U,K,C，n
Output : n天之后公司所拥有的总资金的最大值

sum <- C;//初始化
K <- 0;//升级次数
for i<-n to 1 do
    if i > U/X2 && sum >= U then
        K <- K + 1;
		sum <- sum - U;
	end
    sum <- sum + X1 + K*X2;
end
return sum;
```

时间复杂度`T(n) = O(n)`.

## 三、

![image-20191124204449755](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\image-20191124204449755.png)

**思路**： 由题意可知，每个木桶的体积大小取决于长度最小的那块木板，判断能否围成符合题意的水桶，即为判断最短的木板与长度第n小的木板之间的长度之差是否小于等于*l*, `|A[n] - Amin| <= l`

`Partition(A,p,r)`

```c
Input : An array A waiting to be sorted, the range of index p,r.
Output : Index of the pivot after partition.
    
x <- A[r];
i <- p-1;
for j <- p to r-1 do
	if A[j] <= x then
		i <- i+1;
		exchange A[i] and A[j];
	end
end
exchange A[i+1] and A[r];
return i + 1;
```

`QuickSort(A,p,r)`

```c
Input : An array A waiting to be sorted, the range of index p,r.
Output : Sorted array A.
    
if p < r then 
	q <- Partition(A,p,r);
	QuickSort(A,p,q-1);
	QuickSort(a,q+1,r);
end 
return A;
```

```c
Input: m块木板的长度集合A，l
Output: 能否围成符合题意的n个木桶
    
A <- QuickSort(A,0,m);
if  A[n] - A[1] > l then 
    return flase;
end
else 
    return true;
end
```

快速排序的时间复杂度为`O(mlogm)`,故算法总的时间复杂度为`O(mlogm)`。

## 四、

![image-20191124204500700](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\image-20191124204500700.png)

1.证明：由|*E*| = |*v*|可知，图G中存在回路

那么分两种情况进行讨论：

1）：图G中每个点的度均为2，且形成回路，则按照回路，以$v_1->v_2->...->v_n->v_1$的方向，依次对添$e_1,e_2,...e_n$加方向即可构造出每个点出度为1的有向图。

2）：图中存在度数为1的结点，则对每个度数为1的结点$v_i$，从图中删去结点$v_i$和$v_i$所连接的边$e_i$，此时图$G'$依然是连通无向图，且满足条件$|E|_{G'}=|V|_{G'}$,重复上述操作，直至$G'$中不存在度数为1的结点，那么此时$G'$中每个点的度数均为2，与(1）中情况相同。先对$G'$执行（1）中的操作，构造出$G'$对应的有向回路，接着逆序恢复删除的结点，即把度数为1的结点$v_k$添加到$G'$中，恢复边$e_k$，连接$v_k$在图$G$中所连接的结点，且以$v_k$为起点，即$v_k$是$e_k$的起点，重复上述步骤，直至恢复到原有的结点数和边数，此时得到$G$对应的每个点出度均为1的有向图。

综上所述，结论得证。

2.

```c
Input : 存有图G的邻接矩阵G[ij]
Output: 定向之后的图G'

for i<-1 to n do
	for j←1 to n do
		G'[i,j] <- G[i,j];	
	end
end


for i<-1 to n do
	degree <- 0;
	point <- 0;
	for j <- 0 to n do
		if G[i,j] == 1 then
			degree <- degree + 1;
			point <- j;
		end
	end
        
    if degree == 1 then
        G'[j,i] <- 0;
        G[i,j] <- 0;
		G[j,i] <- 0;
		judge <- 1;
	end
end
        
for i<-1 to n do
	for j <- 0 to n do
		if G[i,j] == 1 then
            G[j,i] <- 0;
			G'[j,i] <- 0;
            break;
		end
	end
end                
	
return G';
```

算法时间复杂度为$T(n) = O(n^2)$.

## 五、

![image-20191124204511043](C:\Users\yusong\AppData\Roaming\Typora\typora-user-images\image-20191124204511043.png)

分两种情况进行讨论：

设从点$x$到点$y$的路径经过$n$个传送点

1）$n <= 1$:

此时，两点之间的距离即为他们之间的曼哈顿距离$d(i,j) = |x_i - x_j| + |y_i - y_j|$，不存在传送点之间的传送，两点之间的最短距离即为$d(i,j)$;

2) $n > 1$:

找到$x$和$y$分别距离最近的传送点$x'$,$y'$,两点之间最短距离为$d(x,x') + d(y,y')$



`Input：T[n]`, $ x$ , $ y$

`Output：最短路径长度min_distance`

$min_{xx'}←\infty $	;

$min_{yy'}←\infty $	;

`for i<-1 to n do`

​		`if t[i] == 1 then`	

​				$d_x = |x_x-x_i|+|y_x-y_i|$;

​				$d_y=|x_i-x_y|+|y_i-y_y|$;

​				$if \ d_x <min_{xx'}\  then$

​						$min_{xx'}←d_x$	;

​				$end$

​				$if\ d_y<min_{yy'}\ then$

​						$min_{yy'}←d_y$	;

​				$end$

​		`end`

`end`

$d_{xy}=|x_x-x_y|+|y_x-y_y|$;

$if\ d_{xy}<min_{xx'}+min_{yy'}\ then$	

​			$min\_distance←d_{xy}$;

$end$

$else$

​		$min\_distance←min_{xx'}+min_{yy'}$;

$end$

$return$	$min\_distance$;



时间复杂度$T(n) = O(n)$.



讨论同学：刘丽君